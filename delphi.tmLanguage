<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>fileTypes</key>
	<array>
		<string>pas</string>
		<string>dpr</string>
		<string>dfm</string>
		<string>dpk</string>
	</array>
	<key>name</key>
	<string>Delphi</string>
	<key>patterns</key>
	<array>
		<dict>
			<key>include</key>
			<string>#general</string>
		</dict>
	</array>
	<key>repository</key>
	<dict>
		<key>general</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>captures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.comment.delphi</string>
						</dict>
					</dict>
					<key>match</key>
					<string>(//).*$\n?</string>
					<key>name</key>
					<string>comment.line.double-slash.delphi</string>
				</dict>
				<dict>
					<key>begin</key>
					<string>\(\*</string>
					<key>captures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.comment.delphi</string>
						</dict>
					</dict>
					<key>end</key>
					<string>\*\)</string>
					<key>name</key>
					<string>comment.block.delphi.one</string>
				</dict>
				<dict>
					<key>begin</key>
					<string>\{</string>
					<key>captures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.comment.delphi</string>
						</dict>
					</dict>
					<key>end</key>
					<string>\}</string>
					<key>name</key>
					<string>comment.block.delphi.two</string>
				</dict>
				<dict>
					<key>begin</key>
					<string>^\s*(class procedure|class function|property|function|Function|procedure|Procedure|program|constructor|destructor)\s+(?=[A-Za-z_][A-Za-z0-9_]*)</string>
					<key>beginCaptures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>storage.type.function.delphi</string>
						</dict>
					</dict>
					<key>end</key>
					<string>(\:|\;)</string>
					<key>endCaptures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>punctuation.section.function.begin.delphi</string>
						</dict>
					</dict>
					<key>name</key>
					<string>meta.function.delphi</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>begin</key>
							<string>(?=[A-Za-z_][A-Za-z0-9_]*)</string>
							<key>contentName</key>
							<string>entity.name.function.delphi</string>
							<key>end</key>
							<string>(?![A-Za-z0-9_])</string>
							<key>patterns</key>
							<array>
								<dict>
									<key>include</key>
									<string>#entity_name_function</string>
								</dict>
							</array>
						</dict>
						<dict>
							<key>begin</key>
							<string>(\()</string>
							<key>beginCaptures</key>
							<dict>
								<key>1</key>
								<dict>
									<key>name</key>
									<string>punctuation.definition.parameters.begin.delphi</string>
								</dict>
							</dict>
							<key>contentName</key>
							<string>meta.function.parameters.delphi</string>
							<key>end</key>
							<string>(?=\)|\;\s*(?:\;|-\&gt;))</string>
							<key>patterns</key>
							<array>
								<dict>
									<key>captures</key>
									<dict>
										<key>1</key>
										<dict>
											<key>name</key>
											<string>variable.parameter.function.delphi</string>
										</dict>
										<key>2</key>
										<dict>
											<key>name</key>
											<string>punctuation.separator.parameters.delphi</string>
										</dict>
									</dict>
									<key>match</key>
									<string>\b([a-zA-Z_][a-zA-Z_0-9]*)\s*(?:(:|,)|(?=[\n]))</string>
								</dict>
							</array>
						</dict>
						<dict>
							<key>begin</key>
							<string>(\:)\s*(\-&gt;)</string>
							<key>beginCaptures</key>
							<dict>
								<key>1</key>
								<dict>
									<key>name</key>
									<string>punctuation.definition.parameters.end.delphi</string>
								</dict>
								<key>2</key>
								<dict>
									<key>name</key>
									<string>punctuation.separator.annotation.result.delphi</string>
								</dict>
							</dict>
							<key>end</key>
							<string>(\;)</string>
							<key>patterns</key>
							<array>
								<dict>
									<key>include</key>
									<string>$self</string>
								</dict>
							</array>
						</dict>
					</array>
				</dict>
				<dict>
					<key>begin</key>
					<string>^\s*(property|function|Function|procedure|Procedure|program|constructor|destructor)\s+(?=[A-Za-z_][A-Za-z0-9_]*)</string>
					<key>beginCaptures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>storage.type.function.delphi</string>
						</dict>
					</dict>
					<key>end</key>
					<string>(\()|\;|\:\s*</string>
					<key>endCaptures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.parameters.begin.delphi</string>
						</dict>
						<key>2</key>
						<dict>
							<key>name</key>
							<string>invalid.illegal.missing-parameters.delphi</string>
						</dict>
					</dict>
					<key>name</key>
					<string>meta.function.delphi</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>begin</key>
							<string>(?=[A-Za-z_][A-Za-z0-9_]*)</string>
							<key>contentName</key>
							<string>entity.name.function.delphi</string>
							<key>end</key>
							<string>(?![A-Za-z0-9_])</string>
							<key>patterns</key>
							<array>
								<dict>
									<key>include</key>
									<string>#entity_name_function</string>
								</dict>
							</array>
						</dict>
					</array>
				</dict>
				<dict>
					<key>match</key>
					<string>#(\d{1,2}|.)</string>
					<key>name</key>
					<string>string.quoted.single.delphi</string>
				</dict>
				<dict>
					<key>match</key>
					<string>(?&lt;![\d.])\s0x[a-fA-F\d]+|\b\d+(\.\d+)?([eE]-?\d+)?|\.\d+([eE]-?\d+)?</string>
					<key>name</key>
					<string>constant.numeric.delphi</string>
				</dict>
				<dict>
					<key>match</key>
					<string>\b(?i:(@|nil|true|True|false|False))\b</string>
					<key>name</key>
					<string>constant.language.delphi</string>
				</dict>
				<dict>
					<key>begin</key>
					<string>'</string>
					<key>beginCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.string.begin.delphi</string>
						</dict>
					</dict>
					<key>end</key>
					<string>'</string>
					<key>endCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.string.end.delphi</string>
						</dict>
					</dict>
					<key>name</key>
					<string>string.quoted.single.delphi</string>
				</dict>
				<dict>
					<key>begin</key>
					<string>\[(=*)\[</string>
					<key>beginCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.string.begin.delphi</string>
						</dict>
					</dict>
					<key>end</key>
					<string>\]\1\]</string>
					<key>endCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.string.end.delphi</string>
						</dict>
					</dict>
					<key>name</key>
					<string>string.quoted.block.delphi</string>
				</dict>
				<dict>
					<key>begin</key>
					<string>\[</string>
					<key>end</key>
					<string>\]</string>
					<key>name</key>
					<string>meta.arrayindex.delphi</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>include</key>
							<string>#general</string>
						</dict>
					</array>
				</dict>
				<dict>
					<key>match</key>
					<string>(\b(and|or|not)\b)</string>
					<key>name</key>
					<string>keyword.operator.delphi</string>
				</dict>
				<dict>
					<key>match</key>
					<string>\b(?i:(exports|e?|(message?)|library|set|array|file|mod|shl|as|shr|asm|for|begin|object|then|case|goto|of|to|class|if|on|try|const|implementation|type|constructor|in|packed|unit|destructor|inherited|until|div|initialization|program|uses|do|inline|property|var|downto|interface|raise|while|else|is|record|with|end|label|repeat|xor|except|absolute|export|published|abstract|external|near|read|assembler|far|nodefault|resident|at|forward|override|stored|cdecl|index|private|virtual|default|interrupt|protected|write|dynamic|public|ab|length|ord|size|of|chr|lo|pred|succ|hi|low|ptr|swap|high|odd|round|trunc|threadvar|overload|out|finalization|finally|break|return|local|final|unsafe|resourcestring|sealed|dispinterface|static|platform|requires|safecall|automated|stdcall|contains|implements|varargs|readonly|deprecated|package|register|dispid|pascal|reintroduce|writeonly))\b</string>
					<key>name</key>
					<string>keyword.control.delphi</string>
				</dict>
				<dict>
					<key>match</key>
					<string>([A-Za-z_][A-Za-z0-9_\.]*)</string>
					<key>name</key>
					<string>variable.other.delphi</string>
				</dict>
			</array>
		</dict>
	</dict>
	<key>scopeName</key>
	<string>source.delphi</string>
	<key>uuid</key>
	<string>38ec920b-4e04-4fc1-b21b-dd9b6a543647</string>
</dict>
</plist>
